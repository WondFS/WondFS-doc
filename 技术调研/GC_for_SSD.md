下图给出了SSD的内部布局。SSD控制器通过并行通道(Channel)将数据和指令传输到不同的Channel上。一个Channel中包含多个闪存分组(planes) ，多个闪存分组构成一个闪存芯片，每个分组包含若干个闪存块（Block），每个闪存块中包含若干闪存页(Page)。此外，每个分组中拥有一个4KB大小的寄存器，所有的读写闪存页操作都需要经过寄存器的中转。

当一个闪存块中已使用的闪存页超过阈值（如70%），将触发固态盘的GC操作。GC操作从垃圾闪存块中依次读取有效闪存页，利用寄存器写入新的闪存块中。全部迁移完毕后则擦除旧块。
 
那么问题来了，由于垃圾回收需要迁移回收块中的有效数据，当迁移的有效数据中含有大量失效数据时，会增加写放大，影响系统性能。获取 F2FS 文件系统中的失效 LBA 并将其置无效，可以避免垃圾回收过程中不必要的数据迁移 。另外，识别数据的访问热度 并将其分别存放，可以在包含热数据的闪存块中产生大量无效数据，因此，回收包含热数据的闪存块只需要迁移少量的数据，从而提高垃圾回收效率。

![image](https://user-images.githubusercontent.com/33679152/170817577-cd72a7f1-c55f-4293-a0f1-9bc161d24100.png)

在F2FS中，数据发生更新，文件系统会为其分配新的逻辑块地址LBA，旧的LBA则被标记为失效。然而，失效的LBA新型并不会第一是时间传递到底层设备中，只有等F2FS文件系统下发Discard/Trim命令或重用有效LBA，告知底层设备失效LBA对应的数据已经无效。然而，在此之前，固态盘将失效 LBA 识别为有效数据，并在垃圾回收过程中进行数据迁移，从而降低了垃圾回收的效率。

我们预研的文件系统是直接基于闪存的，那么支持操作的地址即使逻辑地址，也是物理地址，那么应该不会存在问题。
但是值得注意的是：同一个Plane里得垃圾回收不会发生阻塞，如果跨Plane进行垃圾回收，因为需要竞争channel资源，会发生阻塞。如下图：

![image](https://user-images.githubusercontent.com/33679152/170817584-547b3d58-db1c-41b1-9fdf-3465f626b659.png)
